"use strict";let f=self.Deno?.createHttpClient({allowHost:!0}),d=class{report=!0;instanceId;#l=!0;#d=!0;#n=2;#c;#s;#a;#i;#e;#o;#t=new Map;#r=new Set;constructor(e,a){if(!Request.prototype.hasOwnProperty("body"))throw this.#d=!1,new Error("Fetch requests do not support streamable bodies");if(typeof self?.WebSocketStream!="function")throw this.#l=!1,new Error("WebSocket does not support streaming");typeof self?.Deno<"u"&&(this.#n=0),this.#s=a,this.#c=e}async start(){let e=this;if(e.#e)switch(e.#e.readyState){case WebSocket.CLOSING:case WebSocket.CLOSED:throw new Error("Attempted reconnection for an active dialer")}e.instanceId=self.crypto?.randomUUID(),e.#a=`${e.#c}/ws/${e.instanceId}`,e.#i=e.#a.replace("http","ws"),e.#e=new WebSocket(`${e.#a}/ctrl?token=${e.#s}`),e.#e.addEventListener("error",a=>{console.warn("Control socket has errored out:",a.error)}),e.#e.addEventListener("close",a=>{console.warn("Control socket closed."),e.#o?.abort()}),e.#e.addEventListener("opened",a=>{console.warn("Control socket is now ready."),e.#o=new AbortController}),e.#e.addEventListener("message",async a=>{let t=JSON.parse(a.data);switch(console.debug(t),t.m){case"PING":{console.debug("Pong!");break}case"APPAT":{switch(t.e?.appat){case"requestEnd":{e.#t.has(t.c)?(e.#t.get(t.c)[2](),console.info("Closed an ongoing upload.")):(e.#r.add(t.c),console.info("Closed a future upload."));break}}break}case"WS":break;case"WT":break;case"HEAD":case"GET":case"POST":case"PUT":case"DELETE":case"OPTIONS":case"PATCH":{let r={method:t.m,signal:e.#o};if(t.hasOwnProperty("e")){if(t.e.hasOwnProperty("r")){r.referrerPolicy="unsafe-url";let s=new URL(t.e.r);r.referrer=t.e.r.replace(`${s.protocol}//${s.hostname}`,"")}t.e.hasOwnProperty("h")&&(r.headers=t.e.h)}try{let n=await new WebSocketStream(`${e.#i}/${t.c}?token=${e.#s}`).opened;switch(t.m){case"POST":case"PUT":case"DELETE":case"OPTIONS":case"PATCH":{let c=n.readable.getReader();r.body=new ReadableStream({queueingStrategy:new ByteLengthQueuingStrategy({highWaterMark:65536}),start:async o=>{e.#t.set(t.c,[o,c,()=>{o.close(),e.#t.delete(t.c)}])},pull:async o=>{if(e.#r.has(t.c))e.#t.get(t.c)[2](),e.#r.delete(t.c);else if(e.#t.has(t.c)){let{value:l,done:u}=await c.read();l!==void 0&&o.enqueue(l),(u||e.#r.has(t.c))&&(e.#t.get(t.c)[2](),e.#r.delete(t.c))}}}),e.#n>1?(r.duplex="half",e.#e.send(`{"c":"${t.c}","s":1,"t":"AppatError","e":"appat.halfDuplex"}`)):r.duplex="full";break}}f&&(r.client=f);let i=await fetch(t.u,r);if(e.report){let c={c:t.c,s:i.status,t:i.statusText,h:{}};for(let[o,l]of i.headers.entries())c.h[o]=l;e.#e.send(JSON.stringify(c))}t.m==="HEAD"?n.close():await i.body.pipeTo(n.writable)}catch(s){if(console.warn(s),e.report){let n={c:t.c,s:0,t:s.name,e:`${s.message}
${s.stack}`};e.#e.send(JSON.stringify(n))}}break}default:console.warn(`Unsupported method: ${t.m}`)}})}};export{d as default};
